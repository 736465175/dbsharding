################分库分表笔记sql
create database `order_db` character set `utf8` collate `utf8_general_ci`;

drop table if exists `t_order_1`;
create table `t_order_1` (
	`order_id` bigint(20) not null comment '订单ID',
	`price` decimal(10,2) not null comment '订单价格',
	`user_id` bigint(20) not null comment '下单用户ID',
	`status` varchar(50) character set `utf8` collate `utf8_general_ci` not null comment '订单状态',
	primary key (`order_id`) using btree
) engine = innoDB character set = utf8 collate = utf8_general_ci row_format = dynamic;

drop table if exists `t_order_2`;
create table `t_order_2` (
	`order_id` bigint(20) not null comment '订单ID',
	`price` decimal(10,2) not null comment '订单价格',
	`user_id` bigint(20) not null comment '下单用户ID',
	`status` varchar(50) character set `utf8` collate `utf8_general_ci` not null comment '订单状态',
	primary key (`order_id`) using btree
) engine = innoDB character set = utf8 collate = utf8_general_ci row_format = dynamic;



******************************************************************************************************************


<!-- https://mvnrepository.com/artifact/org.apache.shardingsphere/sharding-jdbc-spring-boot-starter -->
<dependency>
    <groupId>org.apache.shardingsphere</groupId>
    <artifactId>sharding-jdbc-spring-boot-starter</artifactId>
    <version>4.1.1</version>
</dependency>

1.编写程序
    1.分片规则的配置：配置类容主要是
        数据源m1、
        主键生成策略、order_id，SNOWFLAKE
        配置数据节点、m1.t_order_$->{1..2}
        分片键和策略、order_id，algorithm-expression: t_order_$->{order_id % 2 +1}
2.启动报错：DruidDataSourceAutoConfigure.class Failed to determine a suitable driver class
    解决:
        DruidDataSourceAutoConfigure查看源码:
        1.表明druid是根据spring.datasource.druid找jdbc属性的，如果not found,则根据spring.datasource找jdbc属性，
        一般而言这是不会出现错误的。但是我这里使用了shardingjdbc
        2.就很显然了，他根据spring.datasource.druid或者spring.datasource确实找不到，因为我的结构是spring.shardingsphere.datasource
            解决方式1：
                如果我们用的jar包是druid-spring-boot-starter，则在启动类上排除druid自动配置
                @SpringBootApplication(exclude = {DruidDataSourceAutoConfigure.class})
            解决方式2：不用druid-spring-boot-starter,改为druid

3.使用@Configuration配置类配置分片规则时，程序会报错org.apache.shardingsphere.shardingjdbc.spring.boot.SpringBootConfiguration 数据源为空
    原因是sharding-jdbc读取分片规则配置时默认是从配置文件中读取配置：
        源码：
            @ConditionalOnProperty(
                prefix = "spring.shardingsphere",
                name = {"enabled"},
                havingValue = "true",
                matchIfMissing = true
            )
            @AutoConfigureBefore({DataSourceAutoConfiguration.class})
            public class SpringBootConfiguration implements EnvironmentAware {...}
    解决方案就是在启动类中过滤掉这个类 exclude  SpringBootConfiguration
